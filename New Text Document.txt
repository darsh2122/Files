import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class CobolToCsvConverter {

    private RecordStructure headerStructure;
    private List<RecordStructure> dataStructures = new ArrayList<>();

    public void parseXml(File xmlFile) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document doc = builder.parse(xmlFile);

        NodeList items = doc.getElementsByTagName("item");
        for (int i = 0; i < items.getLength(); i++) {
            Element item = (Element) items.item(i);
            if (!item.getAttribute("level").equals("01")) {
                continue;
            }

            String name = item.getAttribute("name");
            int storageLength = Integer.parseInt(item.getAttribute("storage-length"));

            NodeList childItems = item.getElementsByTagName("item");
            Element child05 = null;
            for (int j = 0; j < childItems.getLength(); j++) {
                Element child = (Element) childItems.item(j);
                if (child.getAttribute("level").equals("05")) {
                    child05 = child;
                    break;
                }
            }
            if (child05 == null) {
                continue;
            }

            if (name.equals("AAREC-HEADER")) {
                List<Field> fields = parseFields(child05);
                headerStructure = new RecordStructure(name, storageLength, fields, null, 0, 0);
            } else {
                String recName = child05.getAttribute("name");
                int recNameStart = 0;
                int recNameLength = 0;

                NodeList fields = child05.getElementsByTagName("item");
                for (int j = 0; j < fields.getLength(); j++) {
                    Element field = (Element) fields.item(j);
                    if (field.getAttribute("name").equals("REC-NAME")) {
                        recNameStart = Integer.parseInt(field.getAttribute("position"));
                        String picture = field.getAttribute("picture");
                        recNameLength = parsePicture(picture);
                        break;
                    }
                }

                List<Field> structFields = parseFields(child05);
                dataStructures.add(new RecordStructure(name, storageLength, structFields, recName, recNameStart, recNameLength));
            }
        }
    }

    private List<Field> parseFields(Element parent) {
        List<Field> fields = new ArrayList<>();
        NodeList fieldNodes = parent.getElementsByTagName("item");
        for (int i = 0; i < fieldNodes.getLength(); i++) {
            Element fieldElem = (Element) fieldNodes.item(i);
            String level = fieldElem.getAttribute("level");
            if (!level.equals("10")) {
                continue;
            }
            String fieldName = fieldElem.getAttribute("name");
            int position = Integer.parseInt(fieldElem.getAttribute("position"));
            String picture = fieldElem.getAttribute("picture");
            int length = parsePicture(picture);
            fields.add(new Field(fieldName, position, length));
        }
        return fields;
    }

    private int parsePicture(String picture) {
        int startIdx = picture.indexOf('(');
        int endIdx = picture.indexOf(')');
        if (startIdx == -1 || endIdx == -1) {
            throw new IllegalArgumentException("Invalid picture format: " + picture);
        }
        String lengthStr = picture.substring(startIdx + 1, endIdx);
        return Integer.parseInt(lengthStr);
    }

    public void convertToCsv(File inputFile, File outputFile) throws IOException {
        List<String> lines = Files.readAllLines(inputFile.toPath(), StandardCharsets.UTF_8);
        if (lines.isEmpty()) {
            return;
        }

        List<String> csvLines = new ArrayList<>();

        // Process header
        if (headerStructure != null) {
            String headerLine = lines.get(0);
            validateLineLength(headerLine, headerStructure.storageLength);
            List<String> headerValues = parseLine(headerLine, headerStructure.fields);
            csvLines.add(toCsvLine(headerValues));
        }

        // Process data lines
        int footerIndex = lines.size() - 1;
        for (int i = 1; i < footerIndex; i++) {
            String line = lines.get(i);
            RecordStructure dataStruct = findMatchingDataStructure(line);
            if (dataStruct == null) {
                throw new IOException("No matching data structure found for line " + (i + 1));
            }
            validateLineLength(line, dataStruct.storageLength);
            List<String> values = parseLine(line, dataStruct.fields);
            csvLines.add(toCsvLine(values));
        }

        // Process footer
        if (footerIndex > 0 && headerStructure != null) {
            String footerLine = lines.get(footerIndex);
            validateLineLength(footerLine, headerStructure.storageLength);
            List<String> footerValues = parseLine(footerLine, headerStructure.fields);
            csvLines.add(toCsvLine(footerValues));
        }

        Files.write(outputFile.toPath(), csvLines, StandardCharsets.UTF_8);
    }

    private RecordStructure findMatchingDataStructure(String line) {
        for (RecordStructure dataStruct : dataStructures) {
            if (line.length() != dataStruct.storageLength) {
                continue;
            }
            int start = dataStruct.recNameStart - 1;
            int end = start + dataStruct.recNameLength;
            if (end > line.length()) {
                continue;
            }
            String recName = line.substring(start, end);
            if (recName.equals(dataStruct.recName)) {
                return dataStruct;
            }
        }
        return null;
    }

    private void validateLineLength(String line, int expected) {
        if (line.length() != expected) {
            throw new IllegalArgumentException("Line length mismatch. Expected: " + expected + ", Actual: " + line.length());
        }
    }

    private List<String> parseLine(String line, List<Field> fields) {
        List<String> values = new ArrayList<>();
        for (Field field : fields) {
            int start = field.start - 1;
            int end = start + field.length;
            if (start > line.length()) {
                values.add("");
            } else {
                if (end > line.length()) {
                    end = line.length();
                }
                String value = line.substring(start, end).trim();
                values.add(value);
            }
        }
        return values;
    }

    private String toCsvLine(List<String> values) {
        return values.stream()
                .map(v -> v.contains(",") ? "\"" + v.replace("\"", "\"\"") + "\"" : v)
                .collect(Collectors.joining(","));
    }

    private static class RecordStructure {
        String name;
        int storageLength;
        List<Field> fields;
        String recName;
        int recNameStart;
        int recNameLength;

        RecordStructure(String name, int storageLength, List<Field> fields, String recName, int recNameStart, int recNameLength) {
            this.name = name;
            this.storageLength = storageLength;
            this.fields = fields;
            this.recName = recName;
            this.recNameStart = recNameStart;
            this.recNameLength = recNameLength;
        }
    }

    private static class Field {
        String name;
        int start;
        int length;

        Field(String name, int start, int length) {
            this.name = name;
            this.start = start;
            this.length = length;
        }
    }

    public
