import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;
import java.util.stream.Collectors;

public class CobolToCsvDynamicConverter {

    private List<RecordStructure> recordStructures = new ArrayList<>();
    private Set<String> allFieldNames = new LinkedHashSet<>();

    public void parseXml(File xmlFile) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document doc = builder.parse(xmlFile);

        NodeList items = doc.getElementsByTagName("item");
        for (int i = 0; i < items.getLength(); i++) {
            Element item = (Element) items.item(i);
            if (!item.getAttribute("level").equals("01")) continue;

            String name = item.getAttribute("name");
            int storageLength = Integer.parseInt(item.getAttribute("storage-length"));
            List<Field> fields = new ArrayList<>();

            // Recursively parse all child elements for fields
            parseFields(item, fields, 0);

            // Add to record structures and collect field names
            recordStructures.add(new RecordStructure(name, storageLength, fields));
            fields.forEach(f -> allFieldNames.add(f.name));
        }
    }

    private void parseFields(Element parent, List<Field> fields, int parentStart) {
        NodeList children = parent.getElementsByTagName("item");
        for (int i = 0; i < children.getLength(); i++) {
            Element child = (Element) children.item(i);
            String level = child.getAttribute("level");
            String picture = child.getAttribute("picture");

            if (picture.isEmpty()) { // Group item
                int groupStart = Integer.parseInt(child.getAttribute("position"));
                parseFields(child, fields, parentStart + groupStart - 1);
            } else { // Elementary item
                int position = parentStart + Integer.parseInt(child.getAttribute("position")) - 1;
                int length = parsePicture(picture);
                String name = child.getAttribute("name");
                boolean isNumeric = picture.startsWith("9");

                fields.add(new Field(name, position, length, isNumeric));
            }
        }
    }

    private int parsePicture(String picture) {
        String lengthStr = picture.substring(picture.indexOf('(') + 1, picture.indexOf(')'));
        return Integer.parseInt(lengthStr);
    }

    public void convertToCsv(File inputFile, File outputFile) throws IOException {
        List<String> lines = Files.readAllLines(inputFile.toPath(), StandardCharsets.UTF_8);
        if (lines.isEmpty()) return;

        List<String> csvLines = new ArrayList<>();
        csvLines.add(String.join(",", allFieldNames)); // CSV header

        // Process all lines
        for (String line : lines) {
            RecordStructure matchedStructure = findMatchingStructure(line);
            if (matchedStructure == null) continue;

            Map<String, String> fieldValues = parseLine(line, matchedStructure.fields);
            csvLines.add(generateCsvLine(fieldValues));
        }

        Files.write(outputFile.toPath(), csvLines, StandardCharsets.UTF_8);
    }

    private RecordStructure findMatchingStructure(String line) {
        for (RecordStructure structure : recordStructures) {
            if (line.length() != structure.storageLength) continue;

            boolean valid = true;
            for (Field field : structure.fields) {
                if (!validateField(line, field)) {
                    valid = false;
                    break;
                }
            }

            if (valid) return structure;
        }
        return null;
    }

    private boolean validateField(String line, Field field) {
        String value = extractValue(line, field);
        if (field.isNumeric && !value.matches("^\\s*[-+]?\\d+\\s*$")) {
            return false;
        }
        return true;
    }

    private Map<String, String> parseLine(String line, List<Field> fields) {
        Map<String, String> values = new HashMap<>();
        for (Field field : fields) {
            values.put(field.name, extractValue(line, field).trim());
        }
        return values;
    }

    private String extractValue(String line, Field field) {
        int start = field.position - 1;
        int end = Math.min(start + field.length, line.length());
        return start < line.length() ? line.substring(start, end) : "";
    }

    private String generateCsvLine(Map<String, String> fieldValues) {
        return allFieldNames.stream()
                .map(name -> fieldValues.getOrDefault(name, ""))
                .map(this::escapeCsv)
                .collect(Collectors.joining(","));
    }

    private String escapeCsv(String value) {
        if (value.contains(",") || value.contains("\"") || value.contains("\n")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }
        return value;
    }

    // Helper classes
    private static class RecordStructure {
        String name;
        int storageLength;
        List<Field> fields;

        RecordStructure(String name, int storageLength, List<Field> fields) {
            this.name = name;
            this.storageLength = storageLength;
            this.fields = fields;
        }
    }

    private static class Field {
        String name;
        int position;
        int length;
        boolean isNumeric;

        Field(String name, int position, int length, boolean isNumeric) {
            this.name = name;
            this.position = position;
            this.length = length;
            this.isNumeric = isNumeric;
        }
    }

    public static void main(String[] args) {
        CobolToCsvDynamicConverter converter = new CobolToCsvDynamicConverter();
        try {
            converter.parseXml(new File("copybook.xml"));
            converter.convertToCsv(new File("input.txt"), new File("output.csv"));
            System.out.println("Conversion completed successfully.");
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("Error during conversion: " + e.getMessage());
        }
    }
}
