import org.w3c.dom.*;
import javax.xml.parsers.*;
import java.io.*;
import java.util.*;

public class CobolConverter {
    private static class FieldDefinition {
        int level;
        String name;
        String type;
        int length;
        int occurs = 1;
        String recordId;
        List<FieldDefinition> children = new ArrayList<>();
        FieldDefinition parent;

        public FieldDefinition(Element element, FieldDefinition parent) {
            this.level = Integer.parseInt(element.getAttribute("level"));
            this.name = element.getAttribute("name");
            this.type = element.getAttribute("type");
            this.recordId = element.getAttribute("record-id");
            this.parent = parent;
            
            if (element.hasAttribute("length")) {
                this.length = Integer.parseInt(element.getAttribute("length"));
            }
            if (element.hasAttribute("occurs")) {
                this.occurs = Integer.parseInt(element.getAttribute("occurs"));
            }
        }
    }

    public static void main(String[] args) {
        try {
            File xmlConfig = new File("copybook.xml");
            File inputFile = new File("data.txt");
            File outputFile = new File("output.csv");
            
            Map<String, FieldDefinition> recordDefinitions = parseXmlConfig(xmlConfig);
            processFile(inputFile, outputFile, recordDefinitions);
            
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static Map<String, FieldDefinition> parseXmlConfig(File xmlFile) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        Document doc = factory.newDocumentBuilder().parse(xmlFile);
        NodeList items = doc.getElementsByTagName("item");
        
        Map<String, FieldDefinition> records = new HashMap<>();
        Deque<FieldDefinition> stack = new ArrayDeque<>();
        
        for (int i = 0; i < items.getLength(); i++) {
            Element element = (Element) items.item(i);
            FieldDefinition current = new FieldDefinition(element, stack.peek());
            
            if (current.level == 1) {
                records.put(current.recordId, current);
                stack.clear();
                stack.push(current);
            } else {
                while (!stack.isEmpty() && stack.peek().level >= current.level) {
                    stack.pop();
                }
                if (!stack.isEmpty()) {
                    stack.peek().children.add(current);
                }
                stack.push(current);
            }
        }
        return records;
    }

    private static void processFile(File input, File output, 
                                  Map<String, FieldDefinition> records) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(input));
             BufferedWriter writer = new BufferedWriter(new FileWriter(output))) {
            
            // Write CSV header
            writer.write(generateHeader(records) + "\n");

            String line;
            while ((line = reader.readLine()) != null) {
                try {
                    String recordId = line.substring(0, 2); // Assuming record-id is first 2 chars
                    FieldDefinition record = records.get(recordId);
                    
                    if (record == null) {
                        throw new Exception("Unknown record type: " + recordId);
                    }
                    
                    String csvLine = parseRecord(line.substring(2), record);
                    writer.write(recordId + "," + csvLine + "\n");
                    
                } catch (Exception e) {
                    System.err.println("Error processing line: " + e.getMessage());
                    // Handle error (e.g., write to error log)
                }
            }
        }
    }

    private static String generateHeader(Map<String, FieldDefinition> records) {
        StringBuilder header = new StringBuilder("RECORD-TYPE,");
        for (FieldDefinition record : records.values()) {
            generateHeaderForRecord(header, record, "");
        }
        return header.toString().replaceAll(",$", "");
    }

    private static void generateHeaderForRecord(StringBuilder header, 
                                              FieldDefinition def, String prefix) {
        for (FieldDefinition child : def.children) {
            if (child.children.isEmpty()) {
                header.append(prefix).append(child.name).append(",");
            } else {
                for (int i = 0; i < child.occurs; i++) {
                    generateHeaderForRecord(header, child, 
                                      prefix + child.name + "_" + i + "_");
                }
            }
        }
    }

    private static String parseRecord(String data, FieldDefinition def) throws Exception {
        return parseGroup(data, def, 0).toString();
    }

    private static StringBuilder parseGroup(String data, FieldDefinition group, int position) 
            throws Exception {
        StringBuilder output = new StringBuilder();
        int occurs = group.occurs;
        int groupLength = calculateLength(group.children) * occurs;

        for (int i = 0; i < occurs; i++) {
            int currentPos = position + (i * (groupLength / occurs));
            for (FieldDefinition child : group.children) {
                if (!child.children.isEmpty()) {
                    output.append(parseGroup(data, child, currentPos));
                } else {
                    if (currentPos + child.length > data.length()) {
                        throw new Exception("Data overflow in field: " + child.name);
                    }
                    String value = data.substring(currentPos, currentPos + child.length).trim();
                    output.append(escapeCsv(value)).append(",");
                    currentPos += child.length;
                }
            }
        }
        return output;
    }

    private static int calculateLength(List<FieldDefinition> fields) {
        int length = 0;
        for (FieldDefinition field : fields) {
            if (field.children.isEmpty()) {
                length += field.length;
            } else {
                length += calculateLength(field.children) * field.occurs;
            }
        }
        return length;
    }

    private static String escapeCsv(String value) {
        if (value.contains(",") || value.contains("\"")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }
        return value;
    }
}
