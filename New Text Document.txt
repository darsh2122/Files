import java.io.BufferedWriter;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.List;

import net.sf.JRecord.Common.Constants;
import net.sf.JRecord.Details.AbstractLine;
import net.sf.JRecord.Details.LayoutDetail;
import net.sf.JRecord.External.CopybookLoader;
import net.sf.JRecord.External.ICopybookDialects;
import net.sf.JRecord.JRecordInterface1;
import net.sf.JRecord.IO.AbstractLineReader;

public class CobolToCsvConverter {

    /**
     * Usage: java CobolToCsvConverter <copybook file> <data file> <csv output>
     */
    public static void main(String[] args) {
        if (args.length < 3) {
            System.out.println("Usage: java CobolToCsvConverter <copybook file> <data file> <csv output>");
            System.exit(1);
        }
        String copybookFile = args[0];
        String dataFile = args[1];
        String csvOutputFile = args[2];

        try {
            // Create a COBOL IO Builder using the new builder API.
            // Note: Replace or adjust the options below to suit your copybook and file:
            var ioBldr = JRecordInterface1.COBOL.newIOBuilder(copybookFile)
                    .setDialect(ICopybookDialects.FMT_MAINFRAME)
                    .setSplitCopybook(CopybookLoader.SPLIT_NONE)
                    // Set the file organization:
                    // Use Constants.IO_FIXED_LENGTH for fixed-length files,
                    // or Constants.IO_VB for variable block (Mainframe VB) files.
                    .setFileOrganization(Constants.IO_FIXED_LENGTH)
                    .setFont("cp037"); // Adjust character set as needed

            // Retrieve the layout details (record schema) derived from the copybook.
            LayoutDetail layout = ioBldr.getLayout();

            // Create the reader using the newIOBuilder API.
            AbstractLineReader reader = ioBldr.newReader(dataFile);

            try (BufferedWriter writer = new BufferedWriter(new FileWriter(csvOutputFile))) {

                // Build the CSV header dynamically from the copybook's field names.
                List<String> headerFields = new ArrayList<>();
                // We assume the copybook contains one record layout.
                for (int i = 0; i < layout.getRecord(0).getFieldCount(); i++) {
                    headerFields.add(layout.getRecord(0).getField(i).getName());
                }
                writer.write(String.join(",", headerFields));
                writer.newLine();

                // Read each record and write CSV rows.
                AbstractLine line;
                while ((line = reader.read()) != null) {
                    List<String> csvFields = new ArrayList<>();
                    for (int i = 0; i < layout.getRecord(0).getFieldCount(); i++) {
                        String fieldValue = line.getFieldValue(0, i).asString();
                        csvFields.add(escapeCsv(fieldValue));
                    }
                    writer.write(String.join(",", csvFields));
                    writer.newLine();
                }
            }
            reader.close();
            System.out.println("Conversion complete. CSV file generated at: " + csvOutputFile);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Escapes CSV fields by surrounding them with quotes if necessary and doubling internal quotes.
     */
    private static String escapeCsv(String value) {
        if (value == null) {
            return "";
        }
        if (value.contains(",") || value.contains("\"") || value.contains("\n") || value.contains("\r")) {
            value = "\"" + value.replace("\"", "\"\"") + "\"";
        }
        return value;
    }
}
